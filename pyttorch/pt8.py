import torch

a = torch.arange(1, 10).view(3, 3)
b = torch.arange(10, 19).view(3, 3)

print(a)
print(b)

r = a * b
print(r)

r1 = torch.mul(a, b) # то же самое умножение
print(r1)

# матричное умножение:
r2 = torch.matmul(a, b)
print(r2)

r3 = torch.mm(a, b) # матричное умножение БЕЗ возможности транслирования
print(r3)

v = torch.LongTensor([-1, -2, -3])
c = torch.matmul(a, v)
print(c) # tensor([-14, -32, -50])

# d = torch.mm(a, v)
# print(d) # нельзя умножить(нет транслирования) матрицу на вектор

c = a.mm(b) # то же самое умножение
print(c)

c = a.matmul(b) # тоже умножение
print(c)


### умножение батчей матриц
bx = torch.randn(7, 3, 5)
print(bx) # 7x3x5 рандомные элементы от 0 до 1
by = torch.randn(7, 5, 4)

# с помощью функции bmm будем умножать 7 раз матрицы 3x5 на матрицу 5x4
bc = torch.bmm(bx, by)
print(bc.size()) # torch.Size([7, 3, 4]) остались наименьшие размерности

# 2 типа произведения векторов - скалярное произведение - перемножение всех элементов между собой
# внешнее произведение - произведение дающее матрицу(все элементы первого вектора умножаются на 1-й элемент второго - 1-я колонка,
# потом на 2-й и так далее, чтобы в результате получить матрицу)

# скалярное:
a = torch.arange(1, 10, dtype=torch.float)
b = torch.ones(9)

c = torch.dot(a, b)
print(c) # 1 + 2 + 3 + ... + 9 = 45

# внешнее произведение - будет матрица
out = torch.outer(a, b)
print(out)


### умножение вектора на матрицу
# вектор на матрицу: элементы вектора умножаются на столбцы и получается результ. вектор
# матрица на вектор: каждая строка матрицы умножается на вектор - получается вектор


a = torch.FloatTensor([1, 2, 3])
b = torch.arange(4, 10, dtype=torch.float32).view(2, 3) # [4, 5, 6], [7, 8, 9]

ba = torch.mv(b, a) # нужно подставлять сначала матрицу, потом вектор, иначе ошибка
print(ba) # 4 * 1 + 5 * 2 + 6 * 3 = 32,   7 * 1 + 8 * 2 + 9 * 3 = 50 => [32, 50]

# а вектор на матрицу не завезли иду нах

# решение СЛАУ с помощью pytorch:
a = torch.FloatTensor([(1, 2, 3), (1, 4, 9), (1, 8, 27)])
aRank = torch.linalg.matrix_rank(a)
print(aRank) # ранг 3 => матрица описывает СЛАУ из 3

y = torch.FloatTensor([10, 20, 30]) # вектор решений СЛАУ
solv = torch.linalg.solve(a, y)
print(solv) # tensor([-5.0000, 10.0000, -1.6667])

# взятие обратной матрицы:
inva = torch.linalg.inv(a)
print(inva)

x = torch.mv(inva, y) # умножаем обратную матрицу на вектор, чтобы найти решения
print(x) # tensor([-5.0000, 10.0000, -1.6667]) ТОЖЕ САМОЕ ЧТО И solv



